% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/environment.R
\name{bru_options}
\alias{bru_options}
\alias{as.bru_options}
\alias{bru_options_default}
\alias{bru_options_check}
\alias{bru_options_get}
\alias{bru_options_set}
\alias{bru_options_reset}
\alias{iinla.getOption}
\alias{iinla.setOption}
\title{Create or update an options objects}
\usage{
bru_options(...)

as.bru_options(x = NULL)

bru_options_default()

bru_options_check(options)

bru_options_get(name = NULL, include_default = TRUE)

bru_options_set(...)

bru_options_reset()

iinla.getOption(name = NULL)

iinla.setOption(...)
}
\arguments{
\item{...}{Named options, optionally started by one or more \code{\link{bru_options}}
objects. Options specified later override the previous options.}

\item{x}{An object to be converted to an \code{bru_options} object.}

\item{options}{An \code{bru_options} object to be checked}

\item{name}{Either \code{NULL}, or single option name string, or character vector
or list with option names,
Default: NULL}

\item{include_default}{logical; If \code{TRUE}, the default options are included
together with the global override options. Default: \code{TRUE}}
}
\value{
\code{bru_options()} returns an \code{bru_options} object.

For \code{as.bru_options()}, \code{NULL} or no input returns an empty
\code{bru_options} object, a \code{list} is converted via \code{bru_options(...)},
and \code{bru_options} input is passed through. Other types of input generates
an error.

\code{bru_options_default()} returns an \code{bru_options} object containing
default options.

\code{bru_options_check()} returns a \code{logical}; \code{TRUE} if the object
contains valid options for use by other functions

\code{bru_options_get} returns either an \code{\link{bru_options}} object, for
\code{name == NULL}, the contents of single option, if \code{name} is a options name
string, or a named list of option contents, if \code{name} is a list of option
name strings.

\code{bru_options_set()} returns a copy of the global options, invisibly.
}
\description{
Create a new options object, or merge information from several
objects.

The \verb{_get}, \verb{_set}, and \verb{_reset} functions operate on a global
package options override object. In many cases, setting options in
specific calls to \code{\link[=bru]{bru()}} is recommended instead.
}
\details{
For \code{bru_options} and \code{bru_options_set}, recognised options are:
\describe{
\item{bru_verbose}{logical or numeric; if \code{TRUE}, log messages of \code{verbosity}
\eqn{\leq 1} are printed by \code{\link[=bru_log_message]{bru_log_message()}}. If numeric, log messages
of
verbosity \eqn{\leq} are printed. Default \code{FALSE}}
\item{bru_verbose_stored}{logical or numeric; if \code{TRUE}, log messages of
\code{verbosity} \eqn{\leq 1} are stored by \code{\link[=bru_log_message]{bru_log_message()}}. If numeric,
log messages of verbosity \eqn{\leq} are stored. Default: 1}
}

\code{bru_options_check} checks for valid contents of an \code{bru_options}
object

\code{bru_options_check()} produces warnings for invalid options.

\code{bru_options_set()} is used to set global package options.

\itemize{
\item bru_run If TRUE, run inference. Otherwise only return configuration needed
to run inference.
\item nru_max_iter maximum number of inla iterations
\item offset the usual \code{INLA::inla} offset. If a nonlinear formula is
used, the resulting Taylor approximation constant will be added to this
automatically.
\item bru_result An \code{inla} object returned from previous calls of
\code{INLA::inla}, \link{bru} or \link{lgcp}. This will be used as a
starting point for further improvement of the approximate posterior.
\item E \code{INLA::inla} 'poisson' likelihood exposure parameter
\item Ntrials \code{INLA::inla} 'binomial' likelihood parameter
\item control.compute INLA option, See \code{INLA::control.compute}
\item control.inla INLA option, See \code{INLA::control.inla}
\item control.fixed INLA option, See \code{INLA::control.fixed}. Warning:
due to how inlabru currently constructs the \code{inla()}, the \code{mean},
\code{prec}, \code{mean.intercept}, and \code{prec.intercept} will have no
effect. Until a more elegant alternative has been implemented, use explicit
\code{mean.linear} and \code{prec.linear} specifications in each
\code{model="linear"} component instead.
\item bru_int_args List of arguments passed all the way to the integration method
\code{ipoints} and \code{int.polygon} for 'cp' family models
\item All options not starting with \code{bru_} are passed on to \code{inla()}, sometimes
after altering according to the needs of the inlabru method.
}

\code{bru_options_reset()} clears the global option overrides.

\itemize{
\item \code{iinla.getOption} is deprecated. Use \code{bru_option_get} instead.
}

\itemize{
\item \code{iinla.setOption} is deprecated. Use \code{bru_option_set} instead.
}
}
\examples{
\dontrun{
if (interactive()) {
  # Combine global and user options:
  options1 <- bru_options(bru_options_get(), bru_verbose = TRUE)
  # Create a proto-options object in two equivalent ways:
  options2 <- as.bru_options(bru_verbose = TRUE)
  options2 <- as.bru_options(list(bru_verbose = TRUE))
  # Combine options objects:
  options3 <- bru_options(options1, options2)
}
}
\dontrun{
if (interactive()) {
  # EXAMPLE1
}
}
\dontrun{
if (interactive()) {
  bru_options_check(bru_options(invalid = "something"))
}
}
\dontrun{
if (interactive()) {
  # EXAMPLE1
}
}
\dontrun{
if (interactive()) {
  bru_options_set(
    bru_verbose = TRUE,
    verbose = TRUE
  )
}
}
}
\seealso{
\code{\link[=bru_options]{bru_options()}}, \code{\link[=bru_options_default]{bru_options_default()}}, \code{\link[=bru_options_get]{bru_options_get()}}
}
